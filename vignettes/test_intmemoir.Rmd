---
title: "test_intmemoir"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{test_intmemoir}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
.libPaths("~/LinRace/Rlib/")
library("devtools")
library("dplyr")
library(ggplot2)
library(FNN)
library(SpaTedSim)
library(plotly)
library(TreeDist)
library("TreeTools")
#library(LineageMap)
library(tidyverse)
library(parallel)
library(MASS)
library(cluster)
library(mclust)
library(RColorBrewer)
load_all()
```

```{r}
expr_all <- read.table("/project/xpan78/data/BaseMEM_Magic/Magic/Figures3_5_and_SupFigures2_4-6/lineage_analysis/mRNA_clusters_all_positions_for_R.txt",
                       sep = "\t", header = FALSE)
# Assign column names
colnames(expr_all) <- c("colony","cellID","Zfp42","Aurka","Tfcp2l1","Esrrb","Tbx3","Zscan4C",
                        "Aebp2","Nodal","Nanog","Otx2","Dnmt3b","Lin28b","state")

```

```{r}
# Subset rows where colony == 2
expr_c2 <- expr_all[expr_all$colony == 2, ]
tree_c2 <- read.tree("/project/xpan78/data/BaseMEM_Magic/Magic/Figures3_5_and_SupFigures2_4-6/lineage_analysis/files_for_LMA/consensus_trees_col2_states_SBC_filt_BEAST_cons.newick")
tree_c2_id <- read.tree("/project/xpan78/data/BaseMEM_Magic/Magic/Figures3_5_and_SupFigures2_4-6/lineage_analysis/BEAST_analysis/Trial4/tree2_id.newick")
tree_c2_id$edge.length <- rep(1,length(tree_c2_id$edge.length))
#tree_c2_id$tip.label <- paste0("cell_",tree_c2_id$tip.label)
```

```{r}
# Subset expr_c2 where cellID is in ncells
expr_sub <- expr_c2[expr_c2$cellID %in% ncells, ]

# Read location data
loc_data_2 <- read.table("/project/xpan78/data/BaseMEM_Magic/Magic/Figures3_5_and_SupFigures2_4-6/lineage_analysis/loc_data_2.csv",
                         sep = " ", header = TRUE)

# Sort by 'node'
loc_data_2 <- loc_data_2[order(loc_data_2$node), ]

# Keep only rows where node is in ncells
loc_data_2 <- loc_data_2[loc_data_2$node %in% ncells, ]

rownames(d_pairwise) <- loc_data_2$node
colnames(d_pairwise) <- loc_data_2$node
```


```{r}
read.sequence <- function(file){
  # Read file lines
lines <- readLines(file)

# Find start and end of the MATRIX block
start <- grep("MATRIX", toupper(lines))
end <- grep(";", lines[start:length(lines)])[[1]] + start - 1

# Extract only data lines
mat_lines <- lines[(start + 1):(end - 1)]
mat_lines <- trimws(mat_lines)
mat_lines <- mat_lines[nzchar(mat_lines)]  # remove empty lines

# Split into names and sequences
parts <- strsplit(mat_lines, "\\s+")
barcodes <- sapply(parts, function(x) x[2])
names(barcodes) <- sapply(parts, function(x) x[1])

barcode_df <- do.call(rbind, strsplit(barcodes, split = ""))
rownames(barcode_df) <- names(barcodes)
return(barcode_df)
}

data_sequence <- read.sequence("/project/xpan78/data/BaseMEM_Magic/Magic/Figures3_5_and_SupFigures2_4-6/lineage_analysis/all_position_barcodes/p2_barcs.nexus")
phyla <- read.tree(text='((1:2, (4:1, 5:1):1):1);')
loc_data <- loc_data_2%>%dplyr::select(x_pos,y_pos)
colnames(loc_data) <- c("x","y")
data_sequence[data_sequence == "?"] <- "-"
df_spatial_continuous <- data.frame(cellid = paste0("cell_",expr_sub$cellID),x = loc_data$x,y = loc_data$y,state = loc_data_2$cell_state)
tree_lm_nj <- Build_LineageMap_pd(data_sequence, df_spatial_continuous, phyla,
                                       threshold = 0.2, backbone_type = "NJ_median",outer_cores = 12,inner_cores = 5,lambda1 = 0.05,lambda2 = 0.1,alpha = 1)

tree_gt <- tree_c2_id
tree_init <- NJ_from_barcode(data_sequence)

loc_gt <- loc_data
cds_nj <- chronological_divergence_score(tree_gt, tree_init)
cds_lm_nj <- chronological_divergence_score(tree_gt, tree_lm_nj)

#calculate spatial topological consistency
#stc_nj <- spatio_topological_consistency(tree_gt, tree_init, loc_data, loc_gt)
#stc_lm_majority <- spatio_topological_consistency(tree_gt, tree_lm_majority, loc_data, loc_gt)
#stc_lm_nj <- spatio_topological_consistency(tree_gt, tree_lm_nj, loc_data, loc_gt)

#calculate generation aware divergence
gad_nj <- generation_aware_divergence(tree_gt, tree_init)
gad_lm_nj <- generation_aware_divergence(tree_gt, tree_lm_nj)

rf_fun <- function(t) RF.dist(tree_gt, t, normalize = TRUE)
nye_fun <- function(t) NyeSimilarity(tree_gt, t, normalize = TRUE)
anc_fun <- function(t) {
  tips <- tree_gt$tip.label
  correct <- 0; total <- 0
  for (tip in tips) {
    anc_true <- Ancestors(tree_gt, tip, type = "all")
    anc_infer <- Ancestors(t, tip, type = "all")
    total <- total + length(anc_true)
    correct <- correct + sum(anc_true %in% anc_infer)
  }
  correct / total
}
path_corr_fun <- function(t) {
  common_tips <- intersect(rownames(cophenetic(tree_gt)), rownames(cophenetic(t)))
  cor(as.vector(cophenetic(tree_gt)[common_tips, common_tips]),
      as.vector(cophenetic(t)[common_tips, common_tips]))
}

benchmark_results <- data.frame(
#mse_nj = mse_fun(loc_init,tree_init),
#mse_lm_majority = mse_fun(loc_lm_majority,tree_lm_majority),
#mse_lm_Q = mse_fun(loc_lm_nj,tree_lm_nj),

  rf_nj = rf_fun(tree_init),
  rf_lm_majority = rf_fun(tree_lm_nj),
  
  nye_nj = nye_fun(tree_init),
  nye_lm_Q = nye_fun(tree_lm_nj),
  
  ancestor_accuracy_nj = anc_fun(tree_init),
  ancestor_accuracy_lm_Q = anc_fun(tree_lm_nj),
  
  path_length_corr_nj = path_corr_fun(tree_init),
  path_length_corr_lm_Q = path_corr_fun(tree_lm_nj),
  
  chronological_divergence_score_nj = cds_nj,
  chronological_divergence_score_lm_Q = cds_lm_nj,
  
  generation_aware_divergence_nj = gad_nj$mean_error,
  generation_aware_divergence_lm_Q = gad_lm_nj$mean_error
  
  #spatio_topological_consistency_nj = stc_nj,
  #spatio_topological_consistency_lm_majority = stc_lm_majority,
  #spatio_topological_consistency_lm_Q = stc_lm_nj

)
```

```{r}
res_lm_nj <- LikelihoodCal_ST_OU(tree_lm_nj, data_sequence, df_spatial_continuous$state,
                                phyla, loc_data,lambda1 = 0.05, lambda2 = 0.1, alpha = 1,estimate_ou_params = TRUE)
loc_lm_nj <- res_lm_nj$loc_data
#loc_lm_ou$id <- loc_lm_nj$id
cs_lm_nj <- res_lm_nj$cell_state_infer

merge_2_trees <- function(subtree1,subtree2){
  # Step 1: create a dummy root with two tips
  dummy_root <- read.tree(text="(A:1,B:1);")
  
  # Step 2: bind subtree1 to tip A and subtree2 to tip B
  temp1 <- bind.tree(dummy_root, subtree1, where=which(dummy_root$tip.label=="A"))
  temp2 <- bind.tree(temp1, subtree2, where=which(temp1$tip.label=="B"))
  
  # Step 3: remove dummy tip labels (optional)
  temp2$tip.label[temp2$tip.label %in% c("A","B")] <- NULL
  
  temp2
}

reroot_tree <- function(tree){
  # --- 1️⃣ Get all internal nodes ---
  internal_nodes <- (Ntip(tree) + 1):max(tree$edge)
  half_count <- floor(Ntip(tree)/2)
  # --- 2️⃣ Compute subtree size balance for each internal node ---
  balance_info <- lapply(internal_nodes, function(node) {
    children <- Descendants(tree, node, "children")
    if (length(children) != 2) return(NULL)
    left_tips <- Descendants(tree, children[1], "tips")[[1]]
    right_tips <- Descendants(tree, children[2], "tips")[[1]]
    list(node = node,
         left_tips = left_tips,
         right_tips = right_tips,
         diff = min(abs(length(left_tips) - half_count),abs(length(right_tips) - half_count)))
  })
  balance_info <- Filter(Negate(is.null), balance_info)
  
  # --- 3️⃣ Pick node with smallest difference (most balanced split) ---
  best_info <- balance_info[[which.min(sapply(balance_info, `[[`, "diff"))]]

  
  # --- 4️⃣ Choose one side’s tip as outgroup ---
  # (doesn't matter which — it just determines orientation)
  outgroup_tip <-  Descendants(tree, best_info$node, "tips")[[1]]
  
  # --- 5️⃣ Reroot the tree using that tip ---
  tree_balanced_root <- root(tree, outgroup = outgroup_tip, resolve.root = FALSE)
  
  # --- 6️⃣ Ladderize for aesthetics ---
  tree_balanced_root$edge.length <- rep(1,length(tree_balanced_root$edge.length))
  
  root_children <- Descendants(tree_balanced_root, Ntip(tree_balanced_root) + 1, "children")
  
  if (length(root_children) > 2) {
    # Count tips under each child
    child_sizes <- sapply(root_children, function(ch) length(Descendants(tree_balanced_root, ch, "tips")[[1]]))
    # Pick the two smallest
    merge_children <- root_children[order(child_sizes)][1:2]
    
    # Extract subtrees
    subtree1 <- extract.clade(tree_balanced_root, merge_children[1])
    subtree2 <- extract.clade(tree_balanced_root, merge_children[2])
    
    # Merge them into a single subtree
    merged_subtree <- merge_2_trees(subtree1, subtree2)  # binary merge
    
    # Remove old children and reattach merged subtree
    #remaining_children <- setdiff(root_children, merge_children)
    remaining_subtree <- extract.clade(tree_balanced_root, root_children[order(child_sizes)][3])
    
    # Rebuild a new tree rooted at a trifurcation (now resolved to binary)
    tree_balanced_root <- merge_2_trees(merged_subtree, remaining_subtree)
  }
  
  # --- 7️⃣ Ladderize and return ---
  tree_balanced_root$edge.length <- rep(1,length(tree_balanced_root$edge.length))
  tree_balanced_root <- reorder(tree_balanced_root, index.only = FALSE)
  return(tree_balanced_root)
}

make_ultrametric <- function(tree) {
  depths <- node.depth.edgelength(tree)
  max_depth <- max(depths[1:Ntip(tree)])
  
  for (i in 1:Ntip(tree)) {
    edge_idx <- which(tree$edge[, 2] == i)
    parent <- tree$edge[edge_idx, 1]
    child_depth <- depths[i]
    # Extend this branch so all leaves reach max_depth
    tree$edge.length[edge_idx] <- tree$edge.length[edge_idx] + (max_depth - child_depth)
  }
  tree
}

get_root_to_leaf_paths <- function(tree) {
  # tree$edge is a matrix of parent-child relationships
  edges <- tree$edge
  
  # Identify the root node
  root <- setdiff(edges[, 1], edges[, 2])
  if (length(root) != 1) {
    stop("The tree must have a single root.")
  }
  root <- root[1]
  
  # Identify leaf nodes (tips)
  leaves <- setdiff(edges[, 2], edges[, 1])
  
  # Recursive helper function to find all paths
  find_paths <- function(current_node, current_path) {
    # Find children of the current node
    children <- edges[edges[, 1] == current_node, 2]
    
    # If no children → it's a leaf, return the completed path
    if (length(children) == 0) {
      return(list(current_path))
    }
    
    # Otherwise, recursively continue down each child
    paths <- lapply(children, function(child) {
      find_paths(child, c(current_path, child))
    })
    
    # Flatten nested list
    do.call(c, paths)
  }
  
  # Start recursion from the root
  paths <- find_paths(root, c(root))
  
  # Return as list of integer vectors
  return(paths)
}
```

```{r}
# --- 1️⃣ Compute depth (generation or time) for z-axis ---
#tree_ultra <- chronos(tree_lm_nj, lambda = 1)
tree_ultra <- reroot_tree(tree_lm_nj)
tree_ultra <- make_ultrametric(tree_ultra)
tree_ultra$edge.length <- rep(1,length(tree_ultra$edge.length))
state_lineages <- list(c(1,4,5))
res_lm_nj <- LikelihoodCal_ST(tree_ultra, data_sequence, df_spatial_continuous$state,
                                state_lineages, loc_data,lambda1 = 0.05, lambda2 = 0.1, alpha = 1)
loc_lm_nj <- res_lm_nj$loc_data
res_lm_nj <- LikelihoodCal_ST_OU(tree_ultra, data_sequence, df_spatial_continuous$state,
                                state_lineages, loc_data,lambda1 = 0.05, lambda2 = 0.1, alpha = 1)
loc_lm_ou<- res_lm_nj$loc_data
loc_lm_ou$id <- loc_lm_nj$id
cs_lm_nj <- res_lm_nj$cell_state_infer
loc_lm_ou$state <- cs_lm_nj



root_node <- Ntip(tree_ultra) + 1
depths <- node.depth.edgelength(tree_ultra)
depths <- depths / max(depths) * 10  # rescale to 0–10 range for visualization

# --- 2️⃣ Combine location + z + inferred cell state ---
df_nodes <- loc_lm_nj %>%
  mutate(
    node = as.numeric(loc_lm_nj$id),
    z = depths[node],
    state = as.factor(cs_lm_nj)   # directly assign inferred states
  )

# --- 3️⃣ Build edge (parent-child) coordinate table ---
edges <- as.data.frame(tree_ultra$edge)
colnames(edges) <- c("parent", "child")

edges_coords <- edges %>%
  left_join(df_nodes %>% rename(x_parent = x, y_parent = y, z_parent = z), by = c("parent" = "node")) %>%
  left_join(df_nodes %>% rename(x_child = x, y_child = y, z_child = z), by = c("child" = "node"))

# --- 4️⃣ Define state colors ---
num_states <- length(unique(df_nodes$state))
palette_colors <- brewer.pal(max(3, min(num_states, 12)), "Set1")
state_colors <- setNames(palette_colors[1:num_states], sort(unique(df_nodes$state)))

# --- 5️⃣ Create interactive 3D plot ---
fig <- plot_ly()

# Add node markers
fig <- fig %>%
  add_markers(
    data = df_nodes,
    x = ~x, y = ~y, z = ~z,
    color = ~state,
    colors = state_colors,
    marker = list(size = 6, opacity = 0.9, line = list(width = 1.5, color = "black")),
    text = ~paste("Node:", node, "<br>State:", state),
    hoverinfo = "text"
  )

# Add connecting edges (ancestor → descendant)
for (i in 1:nrow(edges_coords)) {
  fig <- fig %>% add_trace(
    type = "scatter3d",
    mode = "lines",
    x = c(edges_coords$x_parent[i], edges_coords$x_child[i]),
    y = c(edges_coords$y_parent[i], edges_coords$y_child[i]),
    z = c(edges_coords$z_parent[i], edges_coords$z_child[i]),
    line = list(color = 'black', width = 2.5),
    showlegend = FALSE
  )
}

# --- 6️⃣ Optionally: Add semi-transparent planes for generations ---
for (z_level in unique(df_nodes$z)) {
  fig <- fig %>% add_trace(
    type = "mesh3d",
    x = c(min(df_nodes$x), max(df_nodes$x), max(df_nodes$x), min(df_nodes$x)),
    y = c(min(df_nodes$y), min(df_nodes$y), max(df_nodes$y), max(df_nodes$y)),
    z = rep(z_level, 4),
    color = I("gray"),
    opacity = 0.15,
    showscale = FALSE
  )
}

# --- 7️⃣ Final layout ---
fig <- fig %>%
  layout(scene = list(
    xaxis = list(title = "Spatial X"),
    yaxis = list(title = "Spatial Y"),
    zaxis = list(title = "Lineage Depth"),
    camera = list(eye = list(x = 1.3, y = 1.3, z = 1))
  ))

fig <- fig %>%
  layout(
    scene = list(
      xaxis = list(
        title = list(text = "Spatial X", font = list(size = 22)),
        tickfont = list(size = 18)
      ),
      yaxis = list(
        title = list(text = "Spatial Y", font = list(size = 22)),
        tickfont = list(size = 18)
      ),
      zaxis = list(
        title = list(text = "Lineage Depth", font = list(size = 22)),
        tickfont = list(size = 18)
      ),
      camera = list(eye = list(x = 1.3, y = 1.3, z = 1))
    ),
    margin = list(l = 0, r = 0, b = 0, t = 0),
    font = list(family = "Arial", size = 20, color = "black")
  )
fig <- fig %>%
  layout(scene = list(
    xaxis = list(backgroundcolor = "rgb(245,245,245)"),
    yaxis = list(backgroundcolor = "rgb(245,245,245)"),
    zaxis = list(backgroundcolor = "rgb(245,245,245)")
  ))

```

```{r}
fig <- fig %>%
  layout(
    scene = list(
      camera = list(eye = list(x = 1.6, y = 1.6, z = 0.1))
    )
  )

orca(fig, "tree_3d_view.pdf", width = 1200, height = 900, scale = 2)
```



```{r}
loc_df <- loc_lm_nj %>%
  mutate(
    node = as.numeric(loc_lm_nj$id),
         state = cs_lm_nj)

# Extract edges as data frame (parent-child pairs)
edges_df <- as.data.frame(tree_ultra$edge)
colnames(edges_df) <- c("parent", "child")

# Merge coordinates for edges
edge_coords <- edges_df %>%
  left_join(loc_df, by = c("parent" = "node")) %>%
  rename(x_parent = x, y_parent = y, state_parent = state) %>%
  left_join(loc_df, by = c("child" = "node")) %>%
  rename(x_child = x, y_child = y, state_child = state)

# Define a color palette for states
colors <- c("#e41a1c", "#377eb8", "#4daf4a", "#984ea3",
            "#ff7f00", "#ffff33", "#a65628", "#f781bf", "#999999")
state_levels <- sort(unique(cs_lm_nj))
colors <- setNames(palette_colors[1:num_states], sort(unique(df_nodes$state)))

# Plot
p <- ggplot() +
  # Edges (light gray dashed)
  geom_segment(data = edge_coords,
             aes(x = x_parent, y = y_parent,
                 xend = x_child, yend = y_child),
             color = "gray70", linetype = "dashed",
             linewidth = 0.4, alpha = 0.8,
             arrow = arrow(length = unit(0.3, "cm"),
                           type = "closed", angle = 20)) +
  # Nodes (colored by cell state)
  geom_point(data = loc_df,
             aes(x = x, y = y, color = factor(state)),
             size = 2, alpha = 0.9) +
  scale_color_manual(values = colors, name = "Cell state") +
  theme_minimal(base_size = 14) +
  coord_fixed() +
  labs(x = "x coordinate", y = "y coordinate",
       title = "2D Spatial Visualization of Lineage Tree") +
  theme(
    panel.grid = element_blank(),
    axis.ticks = element_blank(),
    legend.position = "right"
  )
p
```
```{r}
loc_df <- loc_data_2 %>%
  mutate(
    node = as.numeric(rownames(loc_data_2)),
         state = loc_data_2$cell_state)


# Define a color palette for states
colors <- c("#e41a1c", "#377eb8", "#4daf4a", "#984ea3",
            "#ff7f00", "#ffff33", "#a65628", "#f781bf", "#999999")
state_levels <- sort(unique(cs_lm_nj))
colors <- setNames(palette_colors[1:num_states], sort(unique(df_nodes$state)))

# Plot
p <- ggplot() +
  # Edges (light gray dashed)
  # Nodes (colored by cell state)
  geom_point(data = loc_df,
             aes(x = x_pos, y = y_pos, color = factor(state)),
      size = 4, stroke = 0.4, alpha = 0.9) +
  scale_color_manual(values = colors, name = "Cell state") +
  theme_minimal(base_size = 14) +
  coord_fixed() +
  labs(x = "x coordinate", y = "y coordinate",
       title = "2D Spatial Visualization of Lineage Tree") +
  theme(
    panel.grid = element_blank(),
    axis.ticks = element_blank(),
    legend.position = "right"
  )
p+

  # Publication-ready theme
  theme_minimal(base_family = "Helvetica", base_size = 16) +
  theme(
    plot.title = element_text(size = 18, face = "bold", hjust = 0.5),
    axis.title = element_text(size = 16, face = "bold"),
    axis.text = element_text(size = 14, color = "black"),
    axis.ticks = element_line(size = 0.6, color = "black"),
    axis.ticks.length = unit(0.15, "cm"),
    legend.title = element_text(size = 15, face = "bold"),
    legend.text = element_text(size = 13),
    legend.key.size = unit(0.8, "cm"),
    panel.grid = element_blank(),
    plot.margin = margin(10, 10, 10, 10),
    legend.position = "right"
  )
```

```{r}
loc_df <- loc_nj %>%
  mutate(
    node = as.numeric(loc_lm_nj$id),
         state = cs_lm_nj)

# Extract edges as data frame (parent-child pairs)
edges_df <- as.data.frame(tree_ultra$edge)
colnames(edges_df) <- c("parent", "child")

# Merge coordinates for edges
edge_coords <- edges_df %>%
  left_join(loc_df, by = c("parent" = "node")) %>%
  rename(x_parent = x, y_parent = y, state_parent = state) %>%
  left_join(loc_df, by = c("child" = "node")) %>%
  rename(x_child = x, y_child = y, state_child = state)

leaf_nodes <- setdiff(edge_coords$child, edge_coords$parent)
loc_df <- loc_df %>%
  mutate(node_type = ifelse(node %in% leaf_nodes, "Leaf", "Internal"))

# Plot
p <- ggplot() +
  # Edges (light gray dashed)
  #geom_segment(
  #  data = edge_coords,
  #  aes(x = x_parent, y = y_parent, xend = x_child, yend = y_child),
  #  color = "gray70", linetype = "dashed",
  #  linewidth = 0.4, alpha = 0.8
  #) +

  # Nodes (leaf vs internal with different shapes)
  geom_point(
    data = loc_df,
    aes(
      x = x, y = y,
      color = factor(state),
      shape = node_type
    ),
    size = 4, stroke = 0.4, alpha = 0.9
  ) +

  # Manual color & shape scales
  scale_color_manual(values = colors, name = "Cell state") +
  scale_shape_manual(
    values = c("Internal" = 17, "Leaf" = 16),
    name = "Node type"
  ) +

  # Coordinate scaling
  coord_fixed() +

  # Labels
  labs(
    x = "x coordinate",
    y = "y coordinate",
    title = "2D Spatial Visualization of Lineage Tree"
  ) +

  # Publication-ready theme
  theme_minimal(base_family = "Helvetica", base_size = 16) +
  theme(
    plot.title = element_text(size = 18, face = "bold", hjust = 0.5),
    axis.title = element_text(size = 16, face = "bold"),
    axis.text = element_text(size = 14, color = "black"),
    axis.ticks = element_line(size = 0.6, color = "black"),
    axis.ticks.length = unit(0.15, "cm"),
    legend.title = element_text(size = 15, face = "bold"),
    legend.text = element_text(size = 13),
    legend.key.size = unit(0.8, "cm"),
    panel.grid = element_blank(),
    plot.margin = margin(10, 10, 10, 10),
    legend.position = "right"
  )
p
```


```{r}
library(MASS)
library(ggplot2)
library(dplyr)
library(ggnewscale)  # to overlay multiple color scales if needed
library(viridis)

# Example: assume df_nodes and edges_coords from your existing 3D plot
# df_nodes has columns: node, x, y, z, state
# edges_coords has columns: x_parent, y_parent, x_child, y_child

densities <- lapply(split(df_nodes, df_nodes$state), function(subdf) {
  kde <- kde2d(subdf$x, subdf$y, n = 2000)
  df_kde <- with(kde, expand.grid(x = x, y = y))
  df_kde$z <- as.vector(kde$z)
  df_kde$state <- unique(subdf$state)
  df_kde
})
density_df <- do.call(rbind, densities)

# 2️⃣ Normalize densities (for consistent contour scaling)
density_df <- density_df %>%
  group_by(state) %>%
  mutate(z_norm = z / max(z)) %>%
  ungroup()

# 3️⃣ Define colors for states (reuse your current ones)
state_colors <- c("1" = "#E41A1C", "4" = "#377EB8", "5" = "#4DAF4A")

# 4️⃣ Base scatterplot (your existing cell positions and arrows)
p <- ggplot() +
  # Edges (cell division directions)
  geom_segment(
    data = edge_coords,
    aes(x = x_parent, y = y_parent, xend = x_child, yend = y_child),
    color = "gray70", linetype = "dashed", linewidth = 0.5, alpha = 0.7,
    arrow = arrow(length = unit(0.25, "cm"), type = "closed", angle = 20)
  ) +

  # Density boundaries (contours)
  geom_contour(
    data = density_df,
    aes(x = x, y = y, z = z_norm, color = factor(state)),
    bins = 4, linewidth = 1.2, alpha = 0.8
  ) +

  # Optional: softly filled backgrounds for better visibility
  #geom_contour_filled(
  #  data = density_df,
  #  aes(x = x, y = y, z = z_norm, fill = factor(state)),
  #  alpha = 0.25, bins = 5
  #) +

  # Cell positions
  geom_point(
    data = df_nodes, aes(x = x, y = y, color = factor(state)),
    size = 2.8, stroke = 0.4, alpha = 0.9
  ) +

  # --- Scales and legend ---
  scale_color_manual(values = state_colors, name = "Cell state") +
  scale_fill_manual(values = state_colors, name = "Cell state") +
  coord_fixed() +

  # --- Labels ---
  labs(
    title = "2D Spatial Map of Lineage Tree with Cell Type Boundaries",
    x = "Spatial X coordinate",
    y = "Spatial Y coordinate"
  ) +

  # --- Theme: publication-quality tweaks ---
  theme_minimal(base_family = "Helvetica", base_size = 18) +
  theme(
    plot.title = element_text(size = 20, face = "bold", hjust = 0.5),
    axis.title = element_text(size = 18, face = "bold"),
    axis.text = element_text(size = 16, color = "black"),
    axis.ticks = element_line(size = 0.8, color = "black"),
    axis.ticks.length = unit(0.2, "cm"),
    legend.position = c(0.92, 0.8),
    legend.title = element_text(size = 16, face = "bold"),
    legend.text = element_text(size = 14),
    legend.background = element_rect(fill = "white", color = "gray80"),
    panel.grid.major = element_line(color = "gray90", linewidth = 0.3),
    panel.grid.minor = element_blank(),
    plot.margin = margin(15, 15, 15, 15)
  )
```



```{r}
library(gt)
benchmark_results_table <- data.frame(
  Metric = c("RF distance",
             "NYE score",
             "Ancestor accuracy",
             "Path length correlation",
             "Chronological divergence score",
             "Generation-aware divergence"),
  NJ = c(0.8148148,
         0.5283383,
         0.3974359,
         0.5259779,
         1.0000000,
         1.0000000),
  LM_Q = c(0.4074074,  # RF (LM majority) doesn't directly correspond to LM_Q, omit or keep separate
           0.7537037,
           0.4358974,
           0.8773824,
           0.8928571,
           0.9375)
)

benchmark_results_table %>%
  gt() %>%
  fmt_number(columns = c(NJ, LM_Q), decimals = 3) %>%
  tab_header(
    title = "Comparison of Tree Reconstruction Metrics",
    subtitle = "NJ vs LM-Q"
  ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_column_labels(everything())
  ) %>%
  cols_label(
    Metric = "Metric",
    NJ = "NJ",
    LM_Q = "LM-Q"
  )

#knitr::kable(benchmark_results_table, digits = 3,
#      caption = "Comparison of NJ and LM-Q tree reconstruction metrics")

```


```{r}

LineageMap_run_all <- function(colony = c("2","4","5")){
  benchmark_results_all <- c()
  for (colony_id in colony){
    tree_gt <- read.tree(paste0("/project/xpan78/data/BaseMEM_Magic/Magic/Figures3_5_and_SupFigures2_4-6/lineage_analysis/BEAST_analysis/Trial4/tree",colony_id, "_id.newick"))
    tree_gt$edge.length <- rep(1,length(tree_gt$edge.length))
    
    loc_data <- read.table(paste0("/project/xpan78/data/BaseMEM_Magic/Magic/Figures3_5_and_SupFigures2_4-6/lineage_analysis/loc_data_",colony_id,".csv"),
                         sep = " ", header = TRUE)
    
    data_sequence <- read.sequence(paste0("/project/xpan78/data/BaseMEM_Magic/Magic/Figures3_5_and_SupFigures2_4-6/lineage_analysis/all_position_barcodes/p",colony_id,"_barcs.nexus"))
    # Sort by 'node'
    sequenced_cells <- as.numeric(rownames(data_sequence))
    loc_data <- arrange(loc_data,node)
    loc_data <- loc_data[loc_data$node %in% sequenced_cells,]
    
    state_lineages <- list(c(1,4,5),c(1,2,3),c(2,3,4,5))
    loc_data <- loc_data%>%dplyr::select(node,x_pos,y_pos,cell_state)
    rownames(loc_data) <- 1:nrow(loc_data)
    colnames(loc_data) <- c("cellid","x","y","state")
    data_sequence[data_sequence == "?"] <- "-"
    #df_spatial_continuous <- data.frame(cellid = paste0("cell_",expr_sub$cellID),x = loc_data$x,y = loc_data$y,state = loc_data_2$cell_state)
    tree_lm_nj <- Build_LineageMap_pd(data_sequence, loc_data, state_lineages,
                                           threshold = 0.2, backbone_type = "NJ_median",outer_cores = 12,inner_cores = 5,lambda1 = 0.05,lambda2 = 0.1,alpha = 1)
    
    tree_ultra <- reroot_tree(tree_lm_nj)
    tree_ultra <- make_ultrametric(tree_ultra)
    tree_ultra$edge.length <- rep(1,length(tree_ultra$edge.length))
    #state_lineages <- list(c(1,4,5))
    res_lm_nj <- LikelihoodCal_ST(tree_ultra, data_sequence, loc_data$state,
                                    state_lineages, loc_data %>% dplyr::select(x,y),lambda1 = 0.05, lambda2 = 0.1, alpha = 1)
    loc_lm_nj <- res_lm_nj$loc_data
    res_lm_nj <- LikelihoodCal_ST_OU(tree_ultra, data_sequence, loc_data$state,
                                    state_lineages, loc_data %>% dplyr::select(x,y),lambda1 = 0.05, lambda2 = 0.1, alpha = 1)
    loc_lm_ou<- res_lm_nj$loc_data
    loc_lm_ou$id <- loc_lm_nj$id
    cs_lm_nj <- res_lm_nj$cell_state_infer
    loc_lm_ou$state <- cs_lm_nj
    
  
    
    #p1 <- visualize_tree_2d(loc_data,cs_lm_nj,internal = FALSE)
    #p2 <- visualize_tree_2d(loc_lm_ou,cs_lm_nj,internal = TRUE)
    #p3 <- visualize_tree_3d(tree_ultra,loc_lm_nj,cs_lm_nj)
    
    #tree_gt <- tree_c2_id
    tree_init <- NJ_from_barcode(data_sequence)
    res_nj <- LikelihoodCal_ST(tree_init, data_sequence, loc_data$state,
                                    state_lineages, loc_data %>% dplyr::select(x,y),lambda1 = 0.05, lambda2 = 0.1, alpha = 1)
    temp <- res_nj$loc_data
    res_nj <- LikelihoodCal_ST_OU(tree_init, data_sequence, loc_data$state,
                                    state_lineages, loc_data %>% dplyr::select(x,y),lambda1 = 0.05, lambda2 = 0.1, alpha = 1)
    loc_nj <- res_nj$loc_data
    loc_nj$id <- temp$id
    cs_nj <- res_nj$cell_state_infer
    loc_nj$state <- cs_nj
    
    loc_gt <- loc_data
    
    #cds_nj <- chronological_divergence_score(tree_gt, tree_init)
    #cds_lm_nj <- chronological_divergence_score(tree_gt, tree_lm_nj)
    
    #calculate spatial topological consistency
    #stc_nj <- spatio_topological_consistency(tree_gt, tree_init, loc_nj, loc_gt)
    #stc_lm_majority <- spatio_topological_consistency(tree_gt, tree_lm_majority, loc_data, loc_gt)
    #stc_lm_nj <- spatio_topological_consistency(tree_gt, tree_lm_nj, loc_nj, loc_gt)
    
    #calculate generation aware divergence
    #gad_nj <- generation_aware_divergence(tree_gt, tree_init)
    #gad_lm_nj <- generation_aware_divergence(tree_gt, tree_lm_nj)
    
    rf_fun <- function(t) RF.dist(tree_gt, t, normalize = TRUE)
    nye_fun <- function(t) NyeSimilarity(tree_gt, t, normalize = TRUE)
    anc_fun <- function(t) {
      tips <- tree_gt$tip.label
      correct <- 0; total <- 0
      for (tip in tips) {
        anc_true <- Ancestors(tree_gt, tip, type = "all")
        anc_infer <- Ancestors(t, tip, type = "all")
        total <- total + length(anc_true)
        correct <- correct + sum(anc_true %in% anc_infer)
      }
      correct / total
    }
    path_corr_fun <- function(t) {
      common_tips <- intersect(rownames(cophenetic(tree_gt)), rownames(cophenetic(t)))
      cor(as.vector(cophenetic(tree_gt)[common_tips, common_tips]),
          as.vector(cophenetic(t)[common_tips, common_tips]))
    }
    temp <- data.frame(
      mse_nj = mse_fun(loc_nj,tree_init),
      #mse_lm_majority = mse_fun(loc_lm_majority,tree_lm_majority),
      mse_lm_Q = mse_fun(loc_lm_nj,tree_lm_nj),
    
      rf_nj = rf_fun(tree_init),
      rf_lm_Q = rf_fun(tree_ultra),
      
      nye_nj = nye_fun(tree_init),
      nye_lm_Q = nye_fun(tree_ultra),
      
      #ancestor_accuracy_nj = anc_fun(tree_init),
      #ancestor_accuracy_lm_Q = anc_fun(tree_lm_nj),
      
      path_length_corr_nj = path_corr_fun(tree_init),
      path_length_corr_lm_Q = path_corr_fun(tree_ultra),
      
      #chronological_divergence_score_nj = cds_nj,
      #chronological_divergence_score_lm_Q = cds_lm_nj,
      
      #generation_aware_divergence_nj = gad_nj$mean_error,
      #generation_aware_divergence_lm_Q = gad_lm_nj$mean_error,
      
      colony = colony_id
      
      #spatio_topological_consistency_nj = stc_nj,
      #spatio_topological_consistency_lm_majority = stc_lm_majority,
      #spatio_topological_consistency_lm_Q = stc_lm_nj
    
    )
    benchmark_results_all <- rbind(benchmark_results_all,temp)
  }
  benchmark_results_all
}
benchmark_results_all <- LineageMap_run_all()
```

```{r}
#library(FNN)
calculate_spatial_coherence <- function(tree,loc){
  hc <- as.hclust(tree)
  clone_ids <- cutree(hc, k = 4)
  
  # Map tip labels to clone IDs
  tip_labels <- tree$tip.label
  clone_map <- data.frame(cell = tip_labels, clone = clone_ids)
  coords <- as.matrix(df[, c("x", "y")])
  states <- df$state
  loc_df <- loc
  loc_df$cell <- as.character(1:nrow(loc_df))  # adjust if tip labels differ
  loc_df <- merge(loc_df, clone_map, by.x = "cell", by.y = "cell")
  
  # Number of nearest neighbors to consider
  k <- 5
  
  # Find k nearest neighbors (exclude self)
  nn <- get.knnx(coords, coords, k = k + 1)$nn.index[, -1]  # remove first column (self)
  
  # Compute neighborhood purity for each cell
  purity <- sapply(1:nrow(df), function(i) {
    mean(states[nn[i, ]] == states[i])
  })
  
  # Global spatial coherence score
  spatial_coherence_score_state <- mean(purity)
  
  # Output
  print("coherence score by state: ")
  print(spatial_coherence_score_state)
  
  coords <- as.matrix(loc_df[, c("x", "y")])
  clones <- loc_df$clone
  
  k <- 5  # number of nearest neighbors
  
  nn <- get.knnx(coords, coords, k = k + 1)$nn.index[, -1]  # exclude self
  
  # Purity per cell based on clone
  purity <- sapply(1:nrow(loc_df), function(i) {
    mean(clones[nn[i, ]] == clones[i])
  })
  
  # Global spatial coherence score
  spatial_coherence_by_clone <- mean(purity)
  print("coherence score by clone: ")
  print(spatial_coherence_by_clone)
}

calculate_spatial_coherence(make_ultrametric(tree_init),loc_nj)
calculate_spatial_coherence(tree_ultra,loc_lm_nj)
```











